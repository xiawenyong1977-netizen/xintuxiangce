# 🚀 AI结对编程实战提示词库（完整50+模板）

> 精心设计的提示词不是魔法咒语，而是精确的工程指令

## 📋 目录

一、需求与设计阶段 (12个)\
二、编码实现阶段 (22个)\
三、测试与质量 (8个)\
四、调试与优化 (7个)\
五、部署与运维 (6个)\
六、学习与知识管理 (5个)\
附录：使用指南与最佳实践

## 一、需求与设计阶段 (12个模板)

### 1. 产品需求深度挖掘模板

作为资深产品顾问，请帮我深度挖掘以下产品需求：

【产品核心想法】:\[简要描述]

请从以下维度进行需求分析：

1.  用户画像与核心痛点（至少3类用户）
2.  关键使用场景与用户旅程图
3.  成功指标（业务指标与技术指标）
4.  风险识别与缓解策略
5.  MVP功能边界定义

输出格式：结构化文档，每个部分包含具体问题和评估标准。

### 2. 竞品技术架构分析模板

请分析以下竞品的技术实现：

【竞品名称】:\[名称]
【公开信息】:\[官网/GitHub/技术博客等]

分析维度：

1.  技术栈推测与依据
2.  架构模式识别（微服务/单体/Serverless等）
3.  可能的技术选型原因
4.  可借鉴的技术方案
5.  潜在的技术债务或限制

基于分析，为我们的项目提出3条具体的技术建议。

### 3. API契约设计模板

设计RESTful API契约：

【资源】:\[如:用户、订单、产品等]
【操作需求】:\[CRUD操作列表]

要求：

1.  遵循OpenAPI 3.0规范
2.  包含完整的请求/响应示例
3.  详细的错误码定义
4.  分页、过滤、排序参数设计
5.  认证与授权机制说明
6.  速率限制策略

输出完整YAML/JSON格式的OpenAPI文档。

### 4. 数据库Schema设计评审模板

评审数据库设计：

【DDL语句或ER图描述】:\[提供现有设计]

评审要点：

1.  范式化程度是否合适
2.  索引设计策略（覆盖索引、复合索引）
3.  查询性能预估（给出2-3个典型查询的执行计划分析）
4.  扩展性考虑（分库分表策略）
5.  数据一致性方案（事务、最终一致性）
6.  历史数据与归档策略

提供具体的优化建议和改进后的DDL。

### 5. 系统容量规划模板

进行容量规划：

【系统描述】:\[功能与用户量]
【预期指标】:

*   日活用户：\[数量]
*   峰值QPS：\[数值]
*   数据增长：\[每日/每月]
*   SLA要求：\[如99.9%]

请计算：

1.  服务器资源需求（CPU、内存、存储）
2.  网络带宽需求
3.  数据库配置建议
4.  缓存层容量规划
5.  成本预估与优化建议

输出详细的容量规划表格。

### 6. 技术选型对比矩阵模板

对比技术选型：

【候选方案】:\[技术A、技术B、技术C]
【应用场景】:\[具体场景描述]

评估维度（权重可调）：

1.  性能基准（40%）
2.  社区活跃度（20%）
3.  学习曲线（15%）
4.  企业支持（10%）
5.  长期维护性（15%）

请为每个维度提供具体数据和评分，给出加权后的推荐排名。

### 7. 微服务边界划分模板

划分微服务边界：

【单体应用描述】:\[功能模块与数据模型]

拆分原则：

1.  单一职责原则
2.  团队自治边界
3.  数据所有权清晰
4.  通信成本最小化

输出：

1.  服务划分图（包含服务名称与职责）
2.  服务间API契约大纲
3.  数据同步机制建议
4.  部署与监控策略
5.  拆分路线图（分阶段计划）

### 8. 安全威胁建模模板

进行安全威胁建模：

【系统架构】:\[架构图或描述]
【敏感数据】:\[如用户密码、支付信息等]

使用STRIDE模型分析：

1.  欺骗（Spoofing）
2.  篡改（Tampering）
3.  抵赖（Repudiation）
4.  信息泄露（Information Disclosure）
5.  拒绝服务（DoS）
6.  权限提升（Elevation of Privilege）

为每个威胁提供：

*   风险等级评估
*   攻击向量描述
*   防护措施建议
*   检测机制设计

### 9. 用户体验流设计模板

设计用户体验流：

【核心功能】:\[如：用户注册、支付流程等]
【用户类型】:\[如：新用户、老用户等]

要求：

1.  绘制完整用户流程图（可文字描述）
2.  识别关键决策点
3.  设计异常处理路径
4.  优化转化率的关键节点
5.  A/B测试点建议

提供交互原型建议和可用性检查清单。

### 10. 第三方服务集成设计模板

设计第三方服务集成：

【第三方服务】:\[如：支付网关、短信服务、地图API等]
【集成需求】:\[具体功能需求]

设计考虑：

1.  接口适配层设计
2.  错误处理与重试策略
3.  熔断与降级机制
4.  监控与告警配置
5.  数据同步一致性
6.  供应商切换策略

输出集成架构图和关键代码接口设计。

### 11. 数据迁移方案设计模板

设计数据迁移方案：

【源系统】:\[技术栈与数据结构]
【目标系统】:\[新的技术架构]
【数据规模】:\[记录数、数据大小]
【业务约束】:\[停机时间窗口等]

方案包含：

1.  迁移策略选择（一次性/逐步/双写）
2.  数据验证机制
3.  回滚计划
4.  性能影响评估
5.  迁移脚本框架
6.  监控与报警点

提供详细的迁移Checklist和时间表。

### 12. 文档自动生成模板

基于代码生成技术文档：

【代码库信息】:\[语言、框架、关键模块]

生成：

1.  架构概览文档
2.  API文档（自动从注释提取）
3.  部署指南
4.  开发环境配置手册
5.  故障排查手册

要求文档保持与代码同步，提供自动化脚本建议。

## 二、编码实现阶段 (22个模板)

### 13. 函数实现与优化模板

实现并优化以下函数：

【函数签名】:\[如: def process\_data(data: List\[Dict], config: Config) -> Result]
【功能描述】:\[详细描述输入输出]
【性能要求】:\[时间复杂度、内存限制等]
【异常场景】:\[需要处理的异常情况]

实现步骤：

1.  先写测试用例（覆盖正常、边界、异常情况）
2.  实现基础版本
3.  性能分析与瓶颈定位
4.  优化建议（算法优化、内存优化等）
5.  重构为生产级代码

输出完整代码，包含详细注释和性能说明。

### 14. 设计模式应用模板

应用设计模式解决以下问题：

【问题描述】:\[具体的设计问题]
【代码上下文】:\[相关代码片段]

要求：

1.  分析问题适用的设计模式（至少提供2种选择）
2.  对比各方案的优缺点
3.  选择最佳模式并说明理由
4.  实现模式应用
5.  评估模式带来的改进

输出重构前后的代码对比和设计图。

### 15. 并发编程实现模板

实现并发处理：

【任务描述】:\[需要并发执行的任务]
【数据规模】:\[数据量级]
【并发模型】:\[线程/进程/协程/异步]

实现要求：

1.  线程/进程安全保证
2.  资源管理（连接池、内存等）
3.  错误处理与重试
4.  进度监控与取消机制
5.  性能调优建议

输出完整的并发实现代码和性能测试结果。

### 16. 缓存策略实现模板

设计并实现缓存策略：

【缓存场景】:\[如：数据库查询缓存、页面缓存等]
【数据特性】:\[更新频率、数据大小等]

缓存设计：

1.  缓存键设计策略
2.  缓存失效策略（TTL、LRU等）
3.  缓存穿透/击穿/雪崩防护
4.  一致性保证（Write-through/Write-behind）
5.  监控指标设计

实现多级缓存架构，包含本地缓存和分布式缓存。

### 17. 数据验证与清洗模板

实现数据验证与清洗：

【数据源描述】:\[数据类型、质量情况]
【目标质量标准】:\[准确率、完整性要求]

实现：

1.  数据验证规则（格式、范围、业务规则）
2.  异常数据处理策略
3.  数据清洗流程
4.  质量监控指标
5.  自动化修复建议

输出可配置的验证框架和清洗流水线代码。

### 18. 配置管理系统模板

设计配置管理系统：

【配置类型】:\[环境配置、功能开关、业务参数等]
【部署环境】:\[开发、测试、生产等多环境]

设计原则：

1.  配置与代码分离
2.  环境隔离
3.  版本控制与回滚
4.  安全性（敏感信息加密）
5.  动态更新机制

实现配置管理SDK和配置管理界面设计。

### 19. 日志系统设计模板

设计可观测性日志系统：

【系统规模】:\[服务数量、日志量级]
【关键需求】:\[调试、监控、审计等]

日志设计：

1.  结构化日志格式
2.  日志级别策略
3.  关键字段定义（traceId、spanId等）
4.  日志聚合与检索方案
5.  性能影响控制
6.  合规性要求（如GDPR）

输出日志规范文档和SDK实现代码。

### 20. 错误处理框架模板

实现统一的错误处理框架：

【错误类型】:\[业务错误、系统错误、第三方错误等]
【处理需求】:\[用户提示、监控告警、自动恢复等]

框架设计：

1.  错误分类与编码体系
2.  错误传播机制
3.  错误恢复策略
4.  用户友好的错误信息
5.  错误监控与告警

实现跨层错误处理，包含前端展示和后端处理。

### 21. 国际化(i18n)实现模板

实现国际化支持：

【支持语言】:\[如：中文、英文、日文等]
【国际化范围】:\[UI文本、错误信息、日期格式等]

实现方案：

1.  资源文件管理策略
2.  动态语言切换
3.  RTL语言支持（如阿拉伯语）
4.  翻译流程自动化建议
5.  本地化测试方案

输出完整的i18n框架和示例代码。

### 22. 批处理作业模板

设计批处理作业：

【处理任务】:\[如：报表生成、数据清理、数据同步等]
【数据规模】:\[处理数据量]
【时间要求】:\[执行频率、执行时间窗口]

设计要点：

1.  作业调度策略
2.  容错与重试机制
3.  进度跟踪与监控
4.  资源管理与优化
5.  依赖管理

实现可配置的批处理框架和作业管理器。

### 23. 实时流处理模板

实现实时流处理：

【数据源】:\[如：Kafka消息、WebSocket等]
【处理逻辑】:\[实时计算、聚合、过滤等]
【延迟要求】:\[毫秒级/秒级]

架构设计：

1.  流处理框架选型（Flink/Storm/Kafka Streams）
2.  状态管理与检查点
3.  窗口计算策略
4.  背压处理
5.  Exactly-once语义保证

输出流处理拓扑图和核心代码实现。

### 24. 搜索功能实现模板

实现搜索功能：

【搜索对象】:\[如：商品、文档、用户等]
【搜索需求】:\[关键词搜索、筛选排序、相关性排序等]

搜索方案：

1.  搜索引擎选型（Elasticsearch/Solr/数据库全文索引）
2.  索引设计（字段分析、分词策略）
3.  查询优化（布尔查询、模糊搜索、同义词）
4.  搜索结果排序算法
5.  搜索建议与自动补全

实现完整的搜索服务API和索引维护机制。

### 25. 文件上传与处理模板

实现文件上传与处理：

【文件类型】:\[图片、文档、视频等]
【处理需求】:\[格式转换、压缩、水印等]
【存储要求】:\[本地存储、对象存储]

实现功能：

1.  分片上传与断点续传
2.  文件格式验证与病毒扫描
3.  异步处理流水线
4.  存储策略（冷热分离）
5.  访问控制与CDN集成

输出完整的文件处理服务代码。

### 26. 消息队列集成模板

集成消息队列：

【使用场景】:\[异步处理、系统解耦、流量削峰]
【消息特性】:\[顺序性、可靠性、延迟要求]

集成设计：

1.  消息格式设计（Protobuf/JSON Schema）
2.  生产者实现（重试、确认机制）
3.  消费者实现（并发处理、幂等性）
4.  死信队列处理
5.  监控与告警

输出基于RabbitMQ/Kafka/RocketMQ的完整示例。

### 27. 权限系统实现模板

实现细粒度权限系统：

【权限模型】\:RBAC/ABAC模型选择
【资源类型】:\[API、数据、UI元素等]

实现功能：

1.  用户-角色-权限关系管理
2.  权限验证中间件
3.  数据级权限控制
4.  权限缓存策略
5.  权限变更审计

输出权限系统核心模块和API设计。

### 28. 分布式锁实现模板

实现分布式锁：

【使用场景】:\[如：防止重复提交、资源互斥访问等]
【集群规模】:\[节点数量]

实现方案对比：

1.  基于数据库的实现
2.  基于Redis的实现
3.  基于ZooKeeper的实现
4.  基于etcd的实现

为每种方案提供：

*   代码实现
*   可靠性分析
*   性能测试数据
*   适用场景建议

### 29. 限流与熔断模板

实现系统保护机制：

【保护需求】:\[防止过载、快速失败等]
【监控指标】:\[QPS、响应时间、错误率等]

实现功能：

1.  限流算法（令牌桶、漏桶、滑动窗口）
2.  熔断器模式（状态机实现）
3.  降级策略
4.  自动恢复机制
5.  监控面板集成

输出可配置的系统保护框架。

### 30. 工作流引擎实现模板

实现工作流引擎：

【业务流程】:\[审批流、订单流程等]
【节点类型】:\[人工审批、自动执行、条件判断等]

引擎设计：

1.  流程定义语言设计（DSL）
2.  状态机实现
3.  任务调度与分配
4.  流程版本控制
5.  可视化设计器建议

输出工作流引擎核心代码和示例流程。

### 31. 规则引擎实现模板

实现业务规则引擎：

【规则类型】:\[定价规则、风控规则、促销规则等]
【规则复杂度】:\[简单条件/复杂决策树]

引擎设计：

1.  规则DSL设计
2.  规则匹配算法（RETE算法等）
3.  规则优先级与冲突解决
4.  规则版本与灰度发布
5.  性能优化（规则编译、缓存）

输出规则引擎核心实现和管理界面设计。

### 32. 报表系统实现模板

实现报表系统：

【报表类型】:\[运营报表、财务报表、监控报表等]
【数据源】:\[多个业务数据库]

系统设计：

1.  报表模板定义
2.  数据聚合引擎
3.  缓存与预计算策略
4.  导出功能（Excel/PDF）
5.  订阅与推送机制

输出报表生成服务和前端展示组件。

### 33. 通知系统实现模板

实现多渠道通知系统：

【通知类型】:\[邮件、短信、推送、站内信等]
【模板需求】:\[个性化内容、多语言]

系统设计：

1.  通知模板管理
2.  渠道路由与降级
3.  发送频率控制
4.  送达回执跟踪
5.  A/B测试支持

实现统一的通知网关和渠道适配器。

### 34. 代码生成器模板

创建代码生成器：

【生成目标】:\[如：CRUD代码、API客户端、DTO等]
【输入源】:\[数据库Schema、OpenAPI文档等]

生成器设计：

1.  模板引擎选择（Velocity/FreeMarker）
2.  元数据提取
3.  自定义规则支持
4.  代码格式化
5.  增量生成与覆盖策略

输出可配置的代码生成器和示例模板。

## 三、测试与质量保障 (8个模板)

### 35. 单元测试策略模板

设计单元测试策略：

【项目特性】:\[技术栈、架构模式、复杂度]

测试策略：

1.  测试金字塔规划（各层测试比例）
2.  测试覆盖率目标
3.  Mock策略与框架选择
4.  测试数据管理
5.  测试执行优化（并行执行、测试隔离）

为关键模块设计具体的测试用例模板和测试代码结构。

### 36. 集成测试设计模板

设计集成测试方案：

【集成范围】:\[服务间集成、第三方服务集成]

测试设计：

1.  测试环境管理（Docker Compose/K8s）
2.  测试数据准备与清理
3.  契约测试（Pact/Spring Cloud Contract）
4.  性能基准测试
5.  故障注入测试（Chaos Engineering）

输出集成测试套件框架和关键测试场景。

### 37. E2E自动化测试模板

实现E2E自动化测试：

【测试平台】:\[Web/移动端/API]
【用户流程】:\[核心业务路径]

测试框架：

1.  测试工具选型（Selenium/Cypress/Appium）
2.  页面对象模型设计
3.  测试数据驱动
4.  并行执行与分布式执行
5.  测试报告与可视化

输出完整的E2E测试代码和持续集成配置。

### 38. 性能测试计划模板

制定性能测试计划：

【性能目标】:\[响应时间、吞吐量、并发用户数]
【测试场景】:\[典型用户操作、压力场景]

测试计划：

1.  测试环境规格（与生产环境比例）
2.  测试数据规模
3.  负载模型设计（用户行为模拟）
4.  监控指标定义
5.  性能瓶颈分析方法

输出详细的性能测试脚本和结果分析模板。

### 39. 安全测试用例模板

生成安全测试用例：

【应用类型】:\[Web应用/移动应用/API服务]
【安全标准】:\[OWASP Top 10等]

测试用例覆盖：

1.  认证与授权测试
2.  输入验证测试
3.  敏感数据保护测试
4.  配置安全测试
5.  依赖组件安全测试

提供自动化安全扫描脚本和手动测试检查清单。

### 40. 兼容性测试矩阵模板

设计兼容性测试矩阵：

【支持范围】:\[浏览器、操作系统、设备、API版本等]

测试矩阵设计：

1.  优先级划分（必须支持/推荐支持/可选支持）
2.  测试用例选择策略
3.  自动化测试适配方案
4.  问题跟踪与回归测试
5.  兼容性决策框架

输出详细的兼容性测试计划和执行跟踪表。

### 41. 混沌工程实验模板

设计混沌工程实验：

【系统架构】:\[关键组件与依赖]
【韧性目标】:\[可用性、延迟、数据一致性]

实验设计：

1.  假设定义（稳态假设）
2.  爆炸半径控制（影响范围限制）
3.  故障注入点选择（网络、CPU、内存、磁盘等）
4.  监控与告警验证
5.  实验分析与改进项

输出实验计划、执行脚本和总结报告模板。

### 42. 质量门禁配置模板

配置质量门禁：

【质量指标】:\[代码覆盖率、静态分析、安全扫描等]
【流水线阶段】:\[提交前、构建后、部署前]

门禁策略：

1.  检查项与阈值配置
2.  渐进式严格策略
3.  例外处理流程
4.  质量趋势分析
5.  团队质量评分

输出CI/CD流水线配置和质量看板设计。

## 四、调试与优化 (7个模板)

### 43. 生产问题诊断模板

诊断生产环境问题：

【问题现象】:\[错误信息、监控指标异常]
【影响范围】:\[用户影响、业务影响]
【时间线】:\[首次出现时间、变化趋势]

诊断步骤：

1.  信息收集（日志、指标、追踪）
2.  问题隔离（环境、版本、用户群体）
3.  根因分析（5个为什么）
4.  临时缓解措施
5.  根本解决方案

输出详细的问题诊断报告和行动项。

### 44. 内存泄漏排查模板

排查内存泄漏：

【症状描述】:\[内存持续增长、频繁GC、OOM等]
【环境信息】:\[JVM参数、容器配置]

排查方法：

1.  内存dump获取与分析工具
2.  对象引用链分析
3.  常见泄漏模式检查（集合未清理、监听器未移除等）
4.  压力测试复现
5.  修复验证策略

提供具体的内存分析命令和修复建议。

### 45. 性能优化分析模板

进行性能优化分析：

【性能瓶颈】:\[CPU高、慢查询、高延迟等]
【性能数据】:\[Profiling结果、监控图表]

优化流程：

1.  性能热点识别（80/20原则）
2.  优化方案设计（算法优化、缓存、异步等）
3.  方案评估与选型
4.  A/B测试设计
5.  优化效果度量

输出性能优化方案文档和实验结果。

### 46. 数据库优化模板

优化数据库性能：

【问题SQL】:\[慢查询语句]
【执行计划】:\[EXPLAIN输出]
【表结构】:\[相关表DDL]

优化分析：

1.  索引优化建议（添加、删除、调整索引）
2.  查询重写建议
3.  表结构优化（分区、分表、归档）
4.  连接池配置优化
5.  读写分离方案

提供具体的SQL优化代码和性能对比数据。

### 47. 前端性能优化模板

优化前端性能：

【性能指标】:\[FCP、LCP、CLS等Web Vitals]
【技术栈】:\[React/Vue/Angular等]

优化方向：

1.  资源加载优化（代码分割、懒加载、预加载）
2.  渲染优化（虚拟列表、memoization）
3.  网络优化（HTTP/2、CDN、缓存策略）
4.  包体积优化（Tree Shaking、代码压缩）
5.  运行时优化（Web Workers、WASM）

输出性能优化检查清单和具体实现代码。

### 48. 构建优化模板

优化构建过程：

【构建工具】:\[Webpack/Vite/Gradle/Maven等]
【构建问题】:\[构建时间长、包体积大等]

优化策略：

1.  依赖分析优化（减少不必要的依赖）
2.  并行构建与缓存策略
3.  增量构建优化
4.  构建产物优化
5.  构建环境优化（容器镜像、硬件配置）

提供具体的构建配置优化和性能对比数据。

### 49. 网络优化模板

优化网络性能：

【网络问题】:\[高延迟、丢包、带宽不足等]
【网络拓扑】:\[客户端-边缘-中心架构]

优化方案：

1.  协议优化（QUIC、HTTP/3）
2.  CDN策略优化
3.  连接复用与连接池优化
4.  压缩算法优化（Brotli、Zstd）
5.  预连接与DNS预解析

输出网络优化实施步骤和监控指标。

## 五、部署与运维 (6个模板)

### 50. 容器化部署模板

设计CI/CD流水线：

【代码仓库】:\[GitHub/GitLab等]
【部署目标】:\[K8s、云服务器、Serverless]

流水线阶段：

1.  代码质量检查（静态分析、单元测试）
2.  构建与打包
3.  集成测试
4.  安全扫描
5.  部署与验证
6.  监控与回滚

输出完整的CI/CD配置文件和部署脚本。

### 51. CI/CD流水线模板

设计CI/CD流水线：

【代码仓库】:\[GitHub/GitLab等]
【部署目标】:\[K8s、云服务器、Serverless]

流水线阶段：

1.  代码质量检查（静态分析、单元测试）
2.  构建与打包
3.  集成测试
4.  安全扫描
5.  部署与验证
6.  监控与回滚

输出完整的CI/CD配置文件和部署脚本。

### 52. 蓝绿部署策略模板

设计蓝绿部署策略：

【服务特性】:\[无状态服务、数据库变更需求]
【流量比例】:\[灰度发布比例]

部署策略：

1.  环境准备（数据库迁移、配置管理）
2.  流量切换方案（负载均衡器配置）
3.  健康检查与自动回滚
4.  数据一致性保证
5.  监控与告警配置

输出详细的部署检查清单和回滚方案。

### 53. 监控告警体系模板

设计监控告警体系：

【监控层级】:\[基础设施、应用、业务]
【告警需求】:\[实时性、准确性、可操作性]

监控设计：

1.  指标定义（黄金指标、业务指标）
2.  数据采集方案（Prometheus、Agent）
3.  告警规则设计（多级阈值、持续时间）
4.  告警通知与升级策略
5.  告警抑制与静默

输出监控配置和告警处理流程。

### 54. 灾难恢复计划模板

制定灾难恢复计划：

【恢复目标】\:RTO（恢复时间目标）、RPO（恢复点目标）
【故障场景】:\[数据中心故障、数据库损坏、应用Bug]

恢复计划：

1.  备份策略（频率、保留期、验证）
2.  恢复流程文档
3.  恢复演练计划
4.  人员分工与联系方式
5.  持续改进机制

输出详细的灾难恢复手册和演练报告模板。

### 55. 成本优化分析模板

进行云成本优化分析：

【当前支出】:\[各服务成本明细]
【使用模式】:\[稳态负载、波动负载]

优化方向：

1.  资源利用率分析（CPU、内存、存储）
2.  预留实例优化
3.  存储分层优化（热数据/冷数据）
4.  网络成本优化
5.  自动化伸缩策略

输出成本优化建议和实施路线图。

## 六、学习与知识管理 (5个模板)

### 56. 技术方案学习模板

系统学习技术方案：

【技术主题】:\[如：Kubernetes、GraphQL、Service Mesh等]

学习计划：

1.  知识体系梳理（核心概念、架构、生态）
2.  动手实验设计（从Hello World到生产级配置）
3.  常见问题与解决方案收集
4.  最佳实践总结
5.  团队分享材料准备

输出学习路线图、实验代码和总结文档。

### 57. 代码审查清单模板

创建代码审查清单：

【项目规范】:\[编码规范、架构原则、安全要求]

审查维度：

1.  代码质量（可读性、可维护性、性能）
2.  设计模式应用
3.  测试覆盖
4.  安全漏洞
5.  部署与运维考虑

输出详细的代码审查检查表和自动化检查脚本。

### 58. 技术债务管理模板

管理技术债务：

【债务识别】:\[代码异味、架构缺陷、文档缺失]

管理流程：

1.  债务登记与分类（紧急度、影响度）
2.  偿还优先级评估
3.  偿还计划制定
4.  进度跟踪与报告
5.  预防措施设计

输出技术债务登记表和偿还路线图。

### 59. 项目复盘模板

进行项目复盘：

【项目总结】:\[成功点、失败点、关键数据]

复盘结构：

1.  目标达成情况分析
2.  过程回顾（计划、执行、监控）
3.  根本原因分析（5个为什么）
4.  经验教训总结
5.  改进行动计划

输出详细的复盘报告和改进项跟踪表。

### 60. 技术雷达制定模板

制定团队技术雷达：

【评估维度】:\[采用、试验、评估、暂缓]

技术评估：

1.  新技术发现与跟踪
2.  评估标准定义（成熟度、社区、生产力）
3.  技术采用策略
4.  风险与收益分析
5.  技术推广计划

输出技术雷达图和详细评估报告。

## 附录：使用指南与最佳实践

### 如何高效使用这些模板：

1.  **个性化调整**

    每个模板都包含\[占位符]，使用前替换为具体信息
    根据项目实际情况调整模板结构和优先级
2.  **组合使用策略**

    *示例：新功能开发流程*

    1.  使用模板1进行需求分析
    2.  使用模板3设计API契约
    3.  使用模板13实现核心函数
    4.  使用模板35设计测试策略
    5.  使用模板50设计部署方案
3.  **质量控制**

    *模板输出质量标准*

    *   完整性：所有占位符都已填充
    *   一致性：术语和格式统一
    *   可行性：方案可落地执行
    *   可验证：有明确的验证标准
4.  **持续改进**

    *模板优化循环*

    使用 → 反馈 → 改进 → 标准化

    建议建立团队共享的模板库，定期收集使用反馈进行优化。
5.  **自动化集成**

    *将模板集成到开发流程*

    *   IDE代码片段
    *   CLI工具命令
    *   CI/CD流水线模板
    *   项目管理工具模板

### 模板效果评估指标：

量化评估维度

1.  **效率提升**：任务完成时间减少百分比
2.  **质量提升**：缺陷率降低、测试覆盖率提升
3.  **一致性**：团队产出标准化程度
4.  **知识传承**：新成员上手速度

## 🎯 立即开始使用

1.  **选择3-5个最相关的模板**，从今天开始使用
2.  **建立个人模板库**，在Obsidian/Notion中分类管理
3.  **定期回顾优化**，每月审视模板效果并改进
4.  **团队分享**，将验证有效的模板推广到团队

**记住**：最好的模板是活着的模板——在使用中不断进化。
